var searchIndex = {};
searchIndex['combine_language'] = {"items":[[0,"","combine_language","",null,null],[3,"Lex","","A lexing parser for a language",null,null],[3,"WhiteSpace","","A whitespace parser for a language",null,null],[3,"Reserved","","Parses a reserved word",null,null],[3,"BetweenChar","","Parses `P` between two delimiter characters",null,null],[3,"Identifier","","Defines how to define an identifier (or operator)",null,null],[12,"start","","Parses a valid starting character for an identifier",0,null],[12,"rest","","Parses the rest of the characthers in a valid identifier",0,null],[12,"reserved","","A number of reserved words which cannot be identifiers",0,null],[3,"LanguageDef","","A struct type which contains the necessary definitions to construct a language parser",null,null],[12,"ident","","How to parse an identifier",1,null],[12,"op","","How to parse an operator",1,null],[12,"comment_line","","Describes the start of a line comment",1,null],[12,"comment_start","","Describes the start of a block comment",1,null],[12,"comment_end","","Describes the end of a block comment",1,null],[3,"LanguageEnv","","A type containing parsers for a specific language.",null,null],[3,"Assoc","","Struct for encompassing the associativity of an operator",null,null],[12,"fixity","","Operator fixity",2,null],[12,"precedence","","Operator precedence",2,null],[3,"Expression","","Expression parser which handles binary operators",null,null],[4,"Fixity","","Enumeration on fixities for the expression parser",null,null],[13,"Left","","",3,null],[13,"Right","","",3,null],[5,"expression_parser","","Constructs an expression parser out of a term parser, an operator parser and a function which\ncombines a binary expression to new expressions.",null,{"inputs":[{"name":"p"},{"name":"o"},{"name":"f"}],"output":{"name":"expression"}}],[6,"LanguageParser","","",null,null],[11,"clone","","",4,{"inputs":[{"name":"lex"}],"output":{"name":"lex"}}],[11,"parse_state","","",4,{"inputs":[{"name":"lex"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",4,{"inputs":[{"name":"lex"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",4,{"inputs":[{"name":"lex"},{"name":"parseerror"}],"output":null}],[11,"clone","","",5,{"inputs":[{"name":"whitespace"}],"output":{"name":"whitespace"}}],[11,"parse_state","","",5,{"inputs":[{"name":"whitespace"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_state","","",6,{"inputs":[{"name":"reserved"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",6,{"inputs":[{"name":"reserved"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",6,{"inputs":[{"name":"reserved"},{"name":"parseerror"}],"output":null}],[11,"parse_state","","",7,{"inputs":[{"name":"betweenchar"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",7,{"inputs":[{"name":"betweenchar"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",7,{"inputs":[{"name":"betweenchar"},{"name":"parseerror"}],"output":null}],[11,"new","","Constructs a new parser from a language defintion",8,{"inputs":[{"name":"languageenv"},{"name":"languagedef"}],"output":{"name":"languageenv"}}],[11,"lex","","Creates a lexing parser from `p`",8,{"inputs":[{"name":"languageenv"},{"name":"p"}],"output":{"name":"lex"}}],[11,"white_space","","Skips spaces and comments",8,{"inputs":[{"name":"languageenv"}],"output":{"name":"whitespace"}}],[11,"symbol","","Parses a symbol, lexing the stream if it is successful",8,{"inputs":[{"name":"languageenv"},{"name":"str"}],"output":{"name":"lex"}}],[11,"identifier","","Parses an identifier, failing if it parses something that is a reserved identifier",8,{"inputs":[{"name":"languageenv"}],"output":{"name":"languageparser"}}],[11,"reserved","","Parses the reserved identifier `name`",8,{"inputs":[{"name":"languageenv"},{"name":"str"}],"output":{"name":"reserved"}}],[11,"op","","Parses an operator, failing if it parses something that is a reserved operator",8,{"inputs":[{"name":"languageenv"}],"output":{"name":"languageparser"}}],[11,"reserved_op","","Parses the reserved operator `name`",8,{"inputs":[{"name":"languageenv"},{"name":"str"}],"output":{"name":"reserved"}}],[11,"char_literal","","Parses a character literal taking escape sequences into account",8,{"inputs":[{"name":"languageenv"}],"output":{"name":"languageparser"}}],[11,"string_literal","","Parses a string literal taking character escapes into account",8,{"inputs":[{"name":"languageenv"}],"output":{"name":"languageparser"}}],[11,"angles","","Parses `p` inside angle brackets\n`< p >`",8,{"inputs":[{"name":"languageenv"},{"name":"p"}],"output":{"name":"betweenchar"}}],[11,"braces","","Parses `p` inside braces\n`{ p }`",8,{"inputs":[{"name":"languageenv"},{"name":"p"}],"output":{"name":"betweenchar"}}],[11,"brackets","","Parses `p` inside brackets\n`[ p ]`",8,{"inputs":[{"name":"languageenv"},{"name":"p"}],"output":{"name":"betweenchar"}}],[11,"parens","","Parses `p` inside parentheses\n`( p )`",8,{"inputs":[{"name":"languageenv"},{"name":"p"}],"output":{"name":"betweenchar"}}],[11,"integer","","Parses an integer",8,{"inputs":[{"name":"languageenv"}],"output":{"name":"languageparser"}}],[11,"float","","Parses a floating point number",8,{"inputs":[{"name":"languageenv"}],"output":{"name":"languageparser"}}],[11,"fmt","","",3,{"inputs":[{"name":"fixity"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"bool"}}],[11,"cmp","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"ordering"}}],[11,"eq","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"fixity"},{"name":"fixity"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"fixity"}],"output":{"name":"fixity"}}],[11,"fmt","","",2,{"inputs":[{"name":"assoc"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"bool"}}],[11,"cmp","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"ordering"}}],[11,"eq","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"assoc"},{"name":"assoc"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"assoc"}],"output":{"name":"assoc"}}],[11,"fmt","","",9,{"inputs":[{"name":"expression"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"expression"}],"output":{"name":"expression"}}],[11,"parse_lazy","","",9,{"inputs":[{"name":"expression"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",9,{"inputs":[{"name":"expression"},{"name":"parseerror"}],"output":null}]],"paths":[[3,"Identifier"],[3,"LanguageDef"],[3,"Assoc"],[4,"Fixity"],[3,"Lex"],[3,"WhiteSpace"],[3,"Reserved"],[3,"BetweenChar"],[3,"LanguageEnv"],[3,"Expression"]]};
searchIndex['combine'] = {"items":[[0,"","combine","This crate contains parser combinators, roughly based on the Haskell library [parsec](http://hackage.haskell.org/package/parsec).",null,null],[3,"ParseError","","Struct which hold information about an error that occured at a specific position.\nCan hold multiple instances of `Error` if more that one error occured in the same position.",null,null],[12,"position","","The position where the error occured",0,null],[12,"errors","","A vector containing specific information on what errors occured at `position`",0,null],[3,"State","","The `State<I>` struct keeps track of the current position in the stream `I`",null,null],[12,"position","","The current position",1,null],[12,"input","","The input stream used when items are requested",1,null],[5,"from_iter","","Converts an `Iterator` into a stream.",null,{"inputs":[{"name":"i"}],"output":{"name":"iteratorstream"}}],[5,"char","","Parses a character and succeeds if the characther is equal to `c`",null,{"inputs":[{"name":"char"}],"output":{"name":"token"}}],[5,"digit","","Parses a digit from a stream containing characters",null,{"inputs":[],"output":{"name":"digit"}}],[5,"space","","Parses whitespace",null,{"inputs":[],"output":{"name":"space"}}],[5,"spaces","","Skips over zero or more spaces",null,{"inputs":[],"output":{"name":"spaces"}}],[5,"newline","","Parses a newline character",null,{"inputs":[],"output":{"name":"newline"}}],[5,"crlf","","Parses carriage return and newline, returning the newline character.",null,{"inputs":[],"output":{"name":"crlf"}}],[5,"tab","","Parses a tab character",null,{"inputs":[],"output":{"name":"tab"}}],[5,"upper","","Parses an uppercase letter",null,{"inputs":[],"output":{"name":"upper"}}],[5,"lower","","Parses an lowercase letter",null,{"inputs":[],"output":{"name":"lower"}}],[5,"letter","","Parses an alphabet letter",null,{"inputs":[],"output":{"name":"letter"}}],[5,"alpha_num","","Parses either an alphabet letter or digit",null,{"inputs":[],"output":{"name":"alphanum"}}],[5,"hex_digit","","Parses a hexdecimal digit with uppercase and lowercase",null,{"inputs":[],"output":{"name":"hexdigit"}}],[5,"oct_digit","","Parses an octal digit",null,{"inputs":[],"output":{"name":"octdigit"}}],[5,"string","","Parses the string `s`",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[5,"any","","Parses any token",null,{"inputs":[],"output":{"name":"any"}}],[5,"between","","Parses `open` followed by `parser` followed by `close`\nReturns the value of `parser`",null,{"inputs":[{"name":"l"},{"name":"r"},{"name":"p"}],"output":{"name":"between"}}],[5,"chainl1","","Parses `p` 1 or more times separated by `op`\nThe value returned is the one produced by the left associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainl1"}}],[5,"chainr1","","Parses `p` one or more times separated by `op`\nThe value returned is the one produced by the right associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainr1"}}],[5,"choice","","Takes an array of parsers and tries to apply them each in order.\nFails if all parsers fails or if an applied parser fails after consuming input.",null,{"inputs":[{"name":"s"}],"output":{"name":"choice"}}],[5,"env_parser","","Constructs a parser out of an environment and a function which needs the given environment to\ndo the parsing. This is commonly useful to allow multiple parsers to share some environment\nwhile still allowing the parsers to be written in separate functions.",null,null],[5,"many","","Parses `p` zero or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling many, `many::<Vec<_>, _>(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many"}}],[5,"many1","","Parses `p` one or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling many1 `many1::<Vec<_>, _>(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many1"}}],[5,"optional","","Returns `Some(value)` and `None` on parse failure (always succeeds)",null,{"inputs":[{"name":"p"}],"output":{"name":"optional"}}],[5,"parser","","Wraps a function, turning it into a parser\nMainly needed to turn closures into parsers as function types can be casted to function pointers\nto make them usable as a parser",null,{"inputs":[{"name":"f"}],"output":{"name":"fnparser"}}],[5,"satisfy","","Parses a token and succeeds depending on the result of `predicate`",null,{"inputs":[{"name":"p"}],"output":{"name":"satisfy"}}],[5,"sep_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby"}}],[5,"sep_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by1::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby1"}}],[5,"sep_end_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby"}}],[5,"sep_end_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by1::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby1"}}],[5,"skip_many","","Parses `p` zero or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany"}}],[5,"skip_many1","","Parses `p` one or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany1"}}],[5,"token","","Parses a character and succeeds if the characther is equal to `c`",null,{"inputs":[{"name":"item"}],"output":{"name":"token"}}],[5,"try","","Try acts as `p` except it acts as if the parser hadn't consumed any input\nif `p` returns an error after consuming input",null,{"inputs":[{"name":"p"}],"output":{"name":"try"}}],[5,"value","","Always returns the value `v` without consuming any input.",null,{"inputs":[{"name":"t"}],"output":{"name":"value"}}],[5,"unexpected","","Always fails with `message` as an unexpected error.\nNever consumes any input.",null,{"inputs":[{"name":"s"}],"output":{"name":"unexpected"}}],[5,"not_followed_by","","Succeeds only if `parser` fails.\nNever consumes any input.",null,{"inputs":[{"name":"p"}],"output":{"name":"notfollowedby"}}],[0,"primitives","","Module containing the primitive types which is used to create and compose more advanced parsers",null,null],[3,"SourcePosition","combine::primitives","Struct which represents a position in a source file",null,null],[12,"line","","Current line of the input",2,null],[12,"column","","Current column of the input",2,null],[3,"BytePosition","","Struct which represents a position in a byte stream",null,null],[12,"position","","Current position",3,null],[3,"ParseError","","Struct which hold information about an error that occured at a specific position.\nCan hold multiple instances of `Error` if more that one error occured in the same position.",null,null],[12,"position","","The position where the error occured",0,null],[12,"errors","","A vector containing specific information on what errors occured at `position`",0,null],[3,"State","","The `State<I>` struct keeps track of the current position in the stream `I`",null,null],[12,"position","","The current position",1,null],[12,"input","","The input stream used when items are requested",1,null],[3,"SliceStream","","Newtype for constructing a stream from a slice where the items in the slice are not copyable",null,null],[3,"IteratorStream","","Wrapper around iterators which allows them to be treated as a stream.\nReturned by `from_iter`.",null,null],[4,"Info","","Enum holding error information\nAs there is implementations of `From` for `T: Positioner`, `String` and `&'static str` the\nconstructor need not be used directly as calling `msg.into()` should turn a message into the\ncorrect `Info` variant",null,null],[13,"Token","","",4,null],[13,"Range","","",4,null],[13,"Owned","","",4,null],[13,"Borrowed","","",4,null],[4,"Error","","Enum used to store information about an error that has occured",null,null],[13,"Unexpected","","Error indicating an unexpected token has been encountered in the stream",5,null],[13,"Expected","","Error indicating that the parser expected something else",5,null],[13,"Message","","Generic message",5,null],[13,"Other","","Variant for containing other types of errors",5,null],[4,"Consumed","","Enum used to indicate if a parser consumed any items of the stream it was given as an input",null,null],[13,"Consumed","","Constructor indicating that the parser has consumed elements",6,null],[13,"Empty","","Constructor indicating that the parser did not consume any elements",6,null],[5,"from_iter","","Converts an `Iterator` into a stream.",null,{"inputs":[{"name":"i"}],"output":{"name":"iteratorstream"}}],[6,"ParseResult","","A type alias over the specific `Result` type used by parsers to indicate wether they were\nsuccessful or not.\n`O` is the type that is output on success\n`I` is the specific stream type used in the parser",null,null],[8,"Stream","","A stream is a sequence of items that can be extracted one by one",null,null],[16,"Item","","The type of items which is yielded from this stream",7,null],[16,"Range","","The type of a range of items yielded from this stream.\nTypes which do not a have a way of yielding ranges of items should just use the\nSelf::Item for this type",7,null],[10,"uncons","","Takes a stream and removes its first item, yielding the item and the rest of the elements\nReturns `Err` if no element could be retrieved",7,{"inputs":[{"name":"stream"}],"output":{"name":"result"}}],[8,"Range","","",null,null],[10,"len","","Returns the remaining length of `self`.\nThe returned length need not be the same as the number of items left in the stream",8,{"inputs":[{"name":"range"}],"output":{"name":"usize"}}],[8,"Positioner","","Trait for updating the position for types which can be yielded from a `Stream`.",null,null],[16,"Position","","The type which keeps track of the position.",9,null],[10,"start","","Creates a start position",9,{"inputs":[{"name":"positioner"}],"output":{"name":"position"}}],[10,"update","","Updates the position given that `self` has been taken from the stream",9,{"inputs":[{"name":"positioner"},{"name":"position"}],"output":null}],[8,"Parser","","By implementing the `Parser` trait a type says that it can be used to parse an input stream into\nthe type `Output`.",null,null],[16,"Input","","The type which is take as input for the parser. The type must implement the `Stream` trait\nwhich allows the parser to read item from the type.",10,null],[16,"Output","","The type which is returned if the parser is successful.",10,null],[11,"parse","","Entrypoint of the parser\nTakes some input and tries to parse it returning a `ParseResult`",10,{"inputs":[{"name":"parser"},{"name":"input"}],"output":{"name":"result"}}],[11,"parse_state","","Parses using the state `input` by calling Stream::uncons one or more times\nOn success returns `Ok((value, new_state))` on failure it returns `Err(error)`",10,{"inputs":[{"name":"parser"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","Specialized version of parse_state where the parser does not need to add an error to the\n`ParseError` when it does not consume any input before encountering the error.\nInstead the error can be added later through the `add_error` method",10,{"inputs":[{"name":"parser"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","Adds the first error that would normally be returned by this parser if it failed",10,{"inputs":[{"name":"parser"},{"name":"parseerror"}],"output":null}],[11,"partial_cmp","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"bool"}}],[11,"cmp","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"ordering"}}],[11,"eq","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"sourceposition"},{"name":"sourceposition"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"sourceposition"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"sourceposition"}],"output":{"name":"sourceposition"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"bool"}}],[11,"cmp","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"ordering"}}],[11,"eq","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"byteposition"},{"name":"byteposition"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"byteposition"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"byteposition"}],"output":{"name":"byteposition"}}],[11,"fmt","","",3,{"inputs":[{"name":"byteposition"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"info"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"info"}],"output":{"name":"info"}}],[11,"eq","","",4,{"inputs":[{"name":"info"},{"name":"info"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"info"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",4,{"inputs":[{"name":"info"},{"name":"char"}],"output":{"name":"info"}}],[11,"from","","",4,{"inputs":[{"name":"info"},{"name":"string"}],"output":{"name":"info"}}],[11,"from","","",4,{"inputs":[{"name":"info"},{"name":"str"}],"output":{"name":"info"}}],[11,"fmt","","",5,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"from","","",5,{"inputs":[{"name":"error"},{"name":"e"}],"output":{"name":"error"}}],[11,"end_of_input","","",5,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"fmt","","",6,{"inputs":[{"name":"consumed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"consumed"},{"name":"consumed"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"consumed"},{"name":"consumed"}],"output":{"name":"bool"}}],[11,"clone","","",6,{"inputs":[{"name":"consumed"}],"output":{"name":"consumed"}}],[11,"is_empty","","Returns true if `self` is empty",6,{"inputs":[{"name":"consumed"}],"output":{"name":"bool"}}],[11,"into_inner","","Extracts the contained value",6,{"inputs":[{"name":"consumed"}],"output":{"name":"t"}}],[11,"as_consumed","","Converts `self` into the Consumed state",6,{"inputs":[{"name":"consumed"}],"output":{"name":"consumed"}}],[11,"as_empty","","Converts `self` into theEmpty state",6,{"inputs":[{"name":"consumed"}],"output":{"name":"consumed"}}],[11,"map","","Maps over the contained value without changing the consumed state",6,{"inputs":[{"name":"consumed"},{"name":"f"}],"output":{"name":"consumed"}}],[11,"merge","","",6,{"inputs":[{"name":"consumed"},{"name":"consumed"}],"output":{"name":"consumed"}}],[11,"combine","","Combines the Consumed flags from `self` and the result of `f`",6,{"inputs":[{"name":"consumed"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"new","","",0,{"inputs":[{"name":"parseerror"},{"name":"position"},{"name":"error"}],"output":{"name":"parseerror"}}],[11,"empty","","",0,{"inputs":[{"name":"parseerror"},{"name":"position"}],"output":{"name":"parseerror"}}],[11,"from_errors","","",0,{"inputs":[{"name":"parseerror"},{"name":"position"},{"name":"vec"}],"output":{"name":"parseerror"}}],[11,"end_of_input","","",0,{"inputs":[{"name":"parseerror"},{"name":"position"}],"output":{"name":"parseerror"}}],[11,"add_message","","",0,{"inputs":[{"name":"parseerror"},{"name":"m"}],"output":null}],[11,"add_error","","",0,{"inputs":[{"name":"parseerror"},{"name":"error"}],"output":null}],[11,"set_expected","","",0,{"inputs":[{"name":"parseerror"},{"name":"info"}],"output":null}],[11,"merge","","",0,{"inputs":[{"name":"parseerror"},{"name":"parseerror"}],"output":{"name":"parseerror"}}],[11,"description","","",0,{"inputs":[{"name":"parseerror"}],"output":{"name":"str"}}],[11,"eq","","",0,{"inputs":[{"name":"parseerror"},{"name":"parseerror"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"parseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"parseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"sourceposition"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"state"}],"output":{"name":"state"}}],[11,"fmt","","",1,{"inputs":[{"name":"state"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `State<I>` from an input stream. Initializes the position to\n`Positioner::start()`",1,{"inputs":[{"name":"state"},{"name":"i"}],"output":{"name":"state"}}],[11,"uncons","","`uncons` is the most general way of extracting and item from a stream\nIt takes a function `f` as argument which should update the position\naccording to the item that was extracted\nUsually you want to use `uncons_char` instead which works directly on character streams",1,{"inputs":[{"name":"state"}],"output":{"name":"parseresult"}}],[11,"update","","Updates the `position` and `input` to be as if `item` was removed and `rest` is\nthe remaining input",1,{"inputs":[{"name":"state"},{"name":"item"},{"name":"i"}],"output":{"name":"parseresult"}}],[11,"fmt","","",11,{"inputs":[{"name":"slicestream"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"option"}}],[11,"lt","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"le","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"gt","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"ge","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"cmp","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"ordering"}}],[11,"eq","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"clone","","",11,{"inputs":[{"name":"slicestream"}],"output":{"name":"slicestream"}}],[11,"uncons","","",11,{"inputs":[{"name":"slicestream"}],"output":{"name":"result"}}],[11,"fmt","","",12,{"inputs":[{"name":"iteratorstream"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"iteratorstream"}],"output":{"name":"iteratorstream"}}],[11,"uncons","","",12,{"inputs":[{"name":"iteratorstream"}],"output":{"name":"result"}}],[11,"start","","",11,{"inputs":[{"name":"slicestream"}],"output":{"name":"position"}}],[11,"update","","",11,{"inputs":[{"name":"slicestream"},{"name":"position"}],"output":null}],[11,"parse_state","alloc::boxed","",13,{"inputs":[{"name":"box"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",13,{"inputs":[{"name":"box"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",13,{"inputs":[{"name":"box"},{"name":"parseerror"}],"output":null}],[0,"combinator","combine","Module containing all specific parsers",null,null],[3,"Any","combine::combinator","",null,null],[3,"Satisfy","","",null,null],[3,"Token","","",null,null],[3,"Choice","","",null,null],[3,"Unexpected","","",null,null],[3,"Value","","",null,null],[3,"NotFollowedBy","","",null,null],[3,"Iter","","",null,null],[3,"Many","","",null,null],[3,"Many1","","",null,null],[3,"SkipMany","","",null,null],[3,"SkipMany1","","",null,null],[3,"SepBy","","",null,null],[3,"SepBy1","","",null,null],[3,"SepEndBy","","",null,null],[3,"SepEndBy1","","",null,null],[3,"FnParser","","",null,null],[3,"Optional","","",null,null],[3,"Between","","",null,null],[3,"Chainl1","","",null,null],[3,"Chainr1","","",null,null],[3,"Try","","",null,null],[3,"And","","",null,null],[3,"With","","",null,null],[3,"Skip","","",null,null],[3,"Message","","",null,null],[3,"Or","","",null,null],[3,"Map","","",null,null],[3,"Then","","",null,null],[3,"Expected","","",null,null],[3,"AndThen","","",null,null],[3,"EnvParser","","",null,null],[5,"any","","Parses any token",null,{"inputs":[],"output":{"name":"any"}}],[5,"satisfy","","Parses a token and succeeds depending on the result of `predicate`",null,{"inputs":[{"name":"p"}],"output":{"name":"satisfy"}}],[5,"token","","Parses a character and succeeds if the characther is equal to `c`",null,{"inputs":[{"name":"item"}],"output":{"name":"token"}}],[5,"choice","","Takes an array of parsers and tries to apply them each in order.\nFails if all parsers fails or if an applied parser fails after consuming input.",null,{"inputs":[{"name":"s"}],"output":{"name":"choice"}}],[5,"unexpected","","Always fails with `message` as an unexpected error.\nNever consumes any input.",null,{"inputs":[{"name":"s"}],"output":{"name":"unexpected"}}],[5,"value","","Always returns the value `v` without consuming any input.",null,{"inputs":[{"name":"t"}],"output":{"name":"value"}}],[5,"not_followed_by","","Succeeds only if `parser` fails.\nNever consumes any input.",null,{"inputs":[{"name":"p"}],"output":{"name":"notfollowedby"}}],[5,"many","","Parses `p` zero or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling many, `many::<Vec<_>, _>(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many"}}],[5,"skip_many","","Parses `p` zero or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany"}}],[5,"skip_many1","","Parses `p` one or more times ignoring the result",null,{"inputs":[{"name":"p"}],"output":{"name":"skipmany1"}}],[5,"many1","","Parses `p` one or more times returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling many1 `many1::<Vec<_>, _>(...)`",null,{"inputs":[{"name":"p"}],"output":{"name":"many1"}}],[5,"sep_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby"}}],[5,"sep_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by1::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sepby1"}}],[5,"sep_end_by","","Parses `parser` zero or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby"}}],[5,"sep_end_by1","","Parses `parser` one or more time separated by `separator`, returning a collection with the values from `p`.\nIf the returned collection cannot be inferred type annotations must be supplied, either by\nannotating the resulting type binding `let collection: Vec<_> = ...` or by specializing when\ncalling sep_by, `sep_by1::<Vec<_>, _, _>(...)`",null,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"sependby1"}}],[5,"parser","","Wraps a function, turning it into a parser\nMainly needed to turn closures into parsers as function types can be casted to function pointers\nto make them usable as a parser",null,{"inputs":[{"name":"f"}],"output":{"name":"fnparser"}}],[5,"optional","","Returns `Some(value)` and `None` on parse failure (always succeeds)",null,{"inputs":[{"name":"p"}],"output":{"name":"optional"}}],[5,"between","","Parses `open` followed by `parser` followed by `close`\nReturns the value of `parser`",null,{"inputs":[{"name":"l"},{"name":"r"},{"name":"p"}],"output":{"name":"between"}}],[5,"chainl1","","Parses `p` 1 or more times separated by `op`\nThe value returned is the one produced by the left associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainl1"}}],[5,"chainr1","","Parses `p` one or more times separated by `op`\nThe value returned is the one produced by the right associative application of `op`",null,{"inputs":[{"name":"p"},{"name":"op"}],"output":{"name":"chainr1"}}],[5,"try","","Try acts as `p` except it acts as if the parser hadn't consumed any input\nif `p` returns an error after consuming input",null,{"inputs":[{"name":"p"}],"output":{"name":"try"}}],[5,"env_parser","","Constructs a parser out of an environment and a function which needs the given environment to\ndo the parsing. This is commonly useful to allow multiple parsers to share some environment\nwhile still allowing the parsers to be written in separate functions.",null,null],[8,"ParserExt","","Extension trait which provides functions that are more conveniently used through method calls",null,null],[11,"with","","Discards the value of the `self` parser and returns the value of `p`\nFails if any of the parsers fails",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"with"}}],[11,"skip","","Discards the value of the `p` parser and returns the value of `self`\nFails if any of the parsers fails",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"skip"}}],[11,"and","","Parses with `self` followed by `p`\nSucceds if both parsers succed, otherwise fails\nReturns a tuple with both values on success",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"and"}}],[11,"or","","Returns a parser which first parses using `self`. If `self` fails without consuming any\ninput it then continues by trying to parse using `p`",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"or"}}],[11,"then","","Parses using `self` and then passes the value to `f` which returns a parser used to parse\nthe rest of the input",14,{"inputs":[{"name":"parserext"},{"name":"f"}],"output":{"name":"then"}}],[11,"map","","Uses `f` to map over the parsed value",14,{"inputs":[{"name":"parserext"},{"name":"f"}],"output":{"name":"map"}}],[11,"message","","Parses with `self` and if it fails, adds the message `msg` to the error",14,{"inputs":[{"name":"parserext"},{"name":"s"}],"output":{"name":"message"}}],[11,"expected","","Parses with `self` and if it fails without consuming any input any expected errors are replaced by\n`msg`. `msg` is then used in error messages as \"Expected `msg`\".",14,{"inputs":[{"name":"parserext"},{"name":"s"}],"output":{"name":"expected"}}],[11,"and_then","","Parses with `self` and applies `f` on the result if `self` parses successfully\n`f` may optionally fail with an error which is automatically converted to a `ParseError`",14,{"inputs":[{"name":"parserext"},{"name":"f"}],"output":{"name":"andthen"}}],[11,"iter","","Creates an iterator from a parser and a state. Can be used as an alternative to `many` when\ncollecting directly into a `FromIterator` type is not desirable",14,{"inputs":[{"name":"parserext"},{"name":"state"}],"output":{"name":"iter"}}],[11,"clone","","",15,{"inputs":[{"name":"any"}],"output":{"name":"any"}}],[11,"parse_lazy","","",15,{"inputs":[{"name":"any"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"clone","","",16,{"inputs":[{"name":"satisfy"}],"output":{"name":"satisfy"}}],[11,"parse_lazy","","",16,{"inputs":[{"name":"satisfy"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"clone","","",17,{"inputs":[{"name":"token"}],"output":{"name":"token"}}],[11,"parse_lazy","","",17,{"inputs":[{"name":"token"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",17,{"inputs":[{"name":"token"},{"name":"parseerror"}],"output":null}],[11,"clone","","",18,{"inputs":[{"name":"choice"}],"output":{"name":"choice"}}],[11,"parse_lazy","","",18,{"inputs":[{"name":"choice"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",18,{"inputs":[{"name":"choice"},{"name":"parseerror"}],"output":null}],[11,"clone","","",19,{"inputs":[{"name":"unexpected"}],"output":{"name":"unexpected"}}],[11,"parse_lazy","","",19,{"inputs":[{"name":"unexpected"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",19,{"inputs":[{"name":"unexpected"},{"name":"parseerror"}],"output":null}],[11,"clone","","",20,{"inputs":[{"name":"value"}],"output":{"name":"value"}}],[11,"parse_lazy","","",20,{"inputs":[{"name":"value"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"clone","","",21,{"inputs":[{"name":"notfollowedby"}],"output":{"name":"notfollowedby"}}],[11,"parse_state","","",21,{"inputs":[{"name":"notfollowedby"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",21,{"inputs":[{"name":"notfollowedby"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",21,{"inputs":[{"name":"notfollowedby"},{"name":"parseerror"}],"output":null}],[11,"into_result","","Converts the iterator to a `ParseResult`, returning `Ok` if the parsing so far has be done\nwithout any errors which consumed data.",22,{"inputs":[{"name":"iter"},{"name":"o"}],"output":{"name":"parseresult"}}],[11,"next","","",22,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"clone","","",23,{"inputs":[{"name":"many"}],"output":{"name":"many"}}],[11,"parse_state","","",23,{"inputs":[{"name":"many"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"clone","","",24,{"inputs":[{"name":"many1"}],"output":{"name":"many1"}}],[11,"parse_lazy","","",24,{"inputs":[{"name":"many1"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",24,{"inputs":[{"name":"many1"},{"name":"parseerror"}],"output":null}],[11,"clone","","",25,{"inputs":[{"name":"skipmany"}],"output":{"name":"skipmany"}}],[11,"parse_state","","",25,{"inputs":[{"name":"skipmany"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",25,{"inputs":[{"name":"skipmany"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",25,{"inputs":[{"name":"skipmany"},{"name":"parseerror"}],"output":null}],[11,"clone","","",26,{"inputs":[{"name":"skipmany1"}],"output":{"name":"skipmany1"}}],[11,"parse_state","","",26,{"inputs":[{"name":"skipmany1"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",26,{"inputs":[{"name":"skipmany1"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",26,{"inputs":[{"name":"skipmany1"},{"name":"parseerror"}],"output":null}],[11,"clone","","",27,{"inputs":[{"name":"sepby"}],"output":{"name":"sepby"}}],[11,"parse_lazy","","",27,{"inputs":[{"name":"sepby"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",27,{"inputs":[{"name":"sepby"},{"name":"parseerror"}],"output":null}],[11,"clone","","",28,{"inputs":[{"name":"sepby1"}],"output":{"name":"sepby1"}}],[11,"parse_lazy","","",28,{"inputs":[{"name":"sepby1"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",28,{"inputs":[{"name":"sepby1"},{"name":"parseerror"}],"output":null}],[11,"clone","","",29,{"inputs":[{"name":"sependby"}],"output":{"name":"sependby"}}],[11,"parse_lazy","","",29,{"inputs":[{"name":"sependby"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",29,{"inputs":[{"name":"sependby"},{"name":"parseerror"}],"output":null}],[11,"clone","","",30,{"inputs":[{"name":"sependby1"}],"output":{"name":"sependby1"}}],[11,"parse_lazy","","",30,{"inputs":[{"name":"sependby1"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",30,{"inputs":[{"name":"sependby1"},{"name":"parseerror"}],"output":null}],[11,"parse_state","combine","",31,{"inputs":[{"name":"fnmut"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"clone","combine::combinator","",32,{"inputs":[{"name":"fnparser"}],"output":{"name":"fnparser"}}],[11,"parse_state","","",32,{"inputs":[{"name":"fnparser"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"clone","","",33,{"inputs":[{"name":"optional"}],"output":{"name":"optional"}}],[11,"parse_lazy","","",33,{"inputs":[{"name":"optional"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"clone","","",34,{"inputs":[{"name":"between"}],"output":{"name":"between"}}],[11,"parse_state","","",34,{"inputs":[{"name":"between"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",34,{"inputs":[{"name":"between"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",34,{"inputs":[{"name":"between"},{"name":"parseerror"}],"output":null}],[11,"clone","","",35,{"inputs":[{"name":"chainl1"}],"output":{"name":"chainl1"}}],[11,"parse_lazy","","",35,{"inputs":[{"name":"chainl1"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",35,{"inputs":[{"name":"chainl1"},{"name":"parseerror"}],"output":null}],[11,"clone","","",36,{"inputs":[{"name":"chainr1"}],"output":{"name":"chainr1"}}],[11,"parse_lazy","","",36,{"inputs":[{"name":"chainr1"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",36,{"inputs":[{"name":"chainr1"},{"name":"parseerror"}],"output":null}],[11,"clone","","",37,{"inputs":[{"name":"try"}],"output":{"name":"try"}}],[11,"parse_lazy","","",37,{"inputs":[{"name":"try"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",37,{"inputs":[{"name":"try"},{"name":"parseerror"}],"output":null}],[11,"clone","","",38,{"inputs":[{"name":"and"}],"output":{"name":"and"}}],[11,"parse_lazy","","",38,{"inputs":[{"name":"and"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",38,{"inputs":[{"name":"and"},{"name":"parseerror"}],"output":null}],[11,"clone","","",39,{"inputs":[{"name":"with"}],"output":{"name":"with"}}],[11,"parse_lazy","","",39,{"inputs":[{"name":"with"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",39,{"inputs":[{"name":"with"},{"name":"parseerror"}],"output":null}],[11,"clone","","",40,{"inputs":[{"name":"skip"}],"output":{"name":"skip"}}],[11,"parse_lazy","","",40,{"inputs":[{"name":"skip"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",40,{"inputs":[{"name":"skip"},{"name":"parseerror"}],"output":null}],[11,"clone","","",41,{"inputs":[{"name":"message"}],"output":{"name":"message"}}],[11,"parse_state","","",41,{"inputs":[{"name":"message"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",41,{"inputs":[{"name":"message"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",41,{"inputs":[{"name":"message"},{"name":"parseerror"}],"output":null}],[11,"clone","","",42,{"inputs":[{"name":"or"}],"output":{"name":"or"}}],[11,"parse_lazy","","",42,{"inputs":[{"name":"or"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",42,{"inputs":[{"name":"or"},{"name":"parseerror"}],"output":null}],[11,"clone","","",43,{"inputs":[{"name":"map"}],"output":{"name":"map"}}],[11,"parse_lazy","","",43,{"inputs":[{"name":"map"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",43,{"inputs":[{"name":"map"},{"name":"parseerror"}],"output":null}],[11,"clone","","",44,{"inputs":[{"name":"then"}],"output":{"name":"then"}}],[11,"parse_lazy","","",44,{"inputs":[{"name":"then"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",44,{"inputs":[{"name":"then"},{"name":"parseerror"}],"output":null}],[11,"clone","","",45,{"inputs":[{"name":"expected"}],"output":{"name":"expected"}}],[11,"parse_state","","",45,{"inputs":[{"name":"expected"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","",45,{"inputs":[{"name":"expected"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",45,{"inputs":[{"name":"expected"},{"name":"parseerror"}],"output":null}],[11,"clone","","",46,{"inputs":[{"name":"andthen"}],"output":{"name":"andthen"}}],[11,"parse_lazy","","",46,{"inputs":[{"name":"andthen"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",46,{"inputs":[{"name":"andthen"},{"name":"parseerror"}],"output":null}],[11,"parse_lazy","","",47,{"inputs":[{"name":"envparser"},{"name":"state"}],"output":{"name":"parseresult"}}],[0,"char","combine","Module containg parsers specialized on character streams",null,null],[3,"Digit","combine::char","",null,null],[3,"Space","","",null,null],[3,"Spaces","","",null,null],[3,"NewLine","","",null,null],[3,"CrLf","","",null,null],[3,"Tab","","",null,null],[3,"Upper","","",null,null],[3,"Lower","","",null,null],[3,"AlphaNum","","",null,null],[3,"Letter","","",null,null],[3,"OctDigit","","",null,null],[3,"HexDigit","","",null,null],[3,"String","","",null,null],[5,"char","","Parses a character and succeeds if the characther is equal to `c`",null,{"inputs":[{"name":"char"}],"output":{"name":"token"}}],[5,"digit","","Parses a digit from a stream containing characters",null,{"inputs":[],"output":{"name":"digit"}}],[5,"space","","Parses whitespace",null,{"inputs":[],"output":{"name":"space"}}],[5,"spaces","","Skips over zero or more spaces",null,{"inputs":[],"output":{"name":"spaces"}}],[5,"newline","","Parses a newline character",null,{"inputs":[],"output":{"name":"newline"}}],[5,"crlf","","Parses carriage return and newline, returning the newline character.",null,{"inputs":[],"output":{"name":"crlf"}}],[5,"tab","","Parses a tab character",null,{"inputs":[],"output":{"name":"tab"}}],[5,"upper","","Parses an uppercase letter",null,{"inputs":[],"output":{"name":"upper"}}],[5,"lower","","Parses an lowercase letter",null,{"inputs":[],"output":{"name":"lower"}}],[5,"alpha_num","","Parses either an alphabet letter or digit",null,{"inputs":[],"output":{"name":"alphanum"}}],[5,"letter","","Parses an alphabet letter",null,{"inputs":[],"output":{"name":"letter"}}],[5,"oct_digit","","Parses an octal digit",null,{"inputs":[],"output":{"name":"octdigit"}}],[5,"hex_digit","","Parses a hexdecimal digit with uppercase and lowercase",null,{"inputs":[],"output":{"name":"hexdigit"}}],[5,"string","","Parses the string `s`",null,{"inputs":[{"name":"str"}],"output":{"name":"string"}}],[11,"clone","","",48,{"inputs":[{"name":"digit"}],"output":{"name":"digit"}}],[11,"parse_lazy","","",48,{"inputs":[{"name":"digit"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",48,{"inputs":[{"name":"digit"},{"name":"parseerror"}],"output":null}],[11,"clone","","",49,{"inputs":[{"name":"space"}],"output":{"name":"space"}}],[11,"parse_lazy","","",49,{"inputs":[{"name":"space"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",49,{"inputs":[{"name":"space"},{"name":"parseerror"}],"output":null}],[11,"clone","","",50,{"inputs":[{"name":"spaces"}],"output":{"name":"spaces"}}],[11,"parse_lazy","","",50,{"inputs":[{"name":"spaces"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",50,{"inputs":[{"name":"spaces"},{"name":"parseerror"}],"output":null}],[11,"clone","","",51,{"inputs":[{"name":"newline"}],"output":{"name":"newline"}}],[11,"parse_lazy","","",51,{"inputs":[{"name":"newline"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",51,{"inputs":[{"name":"newline"},{"name":"parseerror"}],"output":null}],[11,"clone","","",52,{"inputs":[{"name":"crlf"}],"output":{"name":"crlf"}}],[11,"parse_lazy","","",52,{"inputs":[{"name":"crlf"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",52,{"inputs":[{"name":"crlf"},{"name":"parseerror"}],"output":null}],[11,"clone","","",53,{"inputs":[{"name":"tab"}],"output":{"name":"tab"}}],[11,"parse_lazy","","",53,{"inputs":[{"name":"tab"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",53,{"inputs":[{"name":"tab"},{"name":"parseerror"}],"output":null}],[11,"clone","","",54,{"inputs":[{"name":"upper"}],"output":{"name":"upper"}}],[11,"parse_lazy","","",54,{"inputs":[{"name":"upper"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",54,{"inputs":[{"name":"upper"},{"name":"parseerror"}],"output":null}],[11,"clone","","",55,{"inputs":[{"name":"lower"}],"output":{"name":"lower"}}],[11,"parse_lazy","","",55,{"inputs":[{"name":"lower"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",55,{"inputs":[{"name":"lower"},{"name":"parseerror"}],"output":null}],[11,"clone","","",56,{"inputs":[{"name":"alphanum"}],"output":{"name":"alphanum"}}],[11,"parse_lazy","","",56,{"inputs":[{"name":"alphanum"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",56,{"inputs":[{"name":"alphanum"},{"name":"parseerror"}],"output":null}],[11,"clone","","",57,{"inputs":[{"name":"letter"}],"output":{"name":"letter"}}],[11,"parse_lazy","","",57,{"inputs":[{"name":"letter"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",57,{"inputs":[{"name":"letter"},{"name":"parseerror"}],"output":null}],[11,"clone","","",58,{"inputs":[{"name":"octdigit"}],"output":{"name":"octdigit"}}],[11,"parse_lazy","","",58,{"inputs":[{"name":"octdigit"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",58,{"inputs":[{"name":"octdigit"},{"name":"parseerror"}],"output":null}],[11,"clone","","",59,{"inputs":[{"name":"hexdigit"}],"output":{"name":"hexdigit"}}],[11,"parse_lazy","","",59,{"inputs":[{"name":"hexdigit"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",59,{"inputs":[{"name":"hexdigit"},{"name":"parseerror"}],"output":null}],[11,"clone","","",60,{"inputs":[{"name":"string"}],"output":{"name":"string"}}],[11,"parse_lazy","","",60,{"inputs":[{"name":"string"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","",60,{"inputs":[{"name":"string"},{"name":"parseerror"}],"output":null}],[6,"ParseResult","combine","A type alias over the specific `Result` type used by parsers to indicate wether they were\nsuccessful or not.\n`O` is the type that is output on success\n`I` is the specific stream type used in the parser",null,null],[8,"Parser","","By implementing the `Parser` trait a type says that it can be used to parse an input stream into\nthe type `Output`.",null,null],[16,"Input","","The type which is take as input for the parser. The type must implement the `Stream` trait\nwhich allows the parser to read item from the type.",10,null],[16,"Output","","The type which is returned if the parser is successful.",10,null],[11,"parse","","Entrypoint of the parser\nTakes some input and tries to parse it returning a `ParseResult`",10,{"inputs":[{"name":"parser"},{"name":"input"}],"output":{"name":"result"}}],[11,"parse_state","","Parses using the state `input` by calling Stream::uncons one or more times\nOn success returns `Ok((value, new_state))` on failure it returns `Err(error)`",10,{"inputs":[{"name":"parser"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"parse_lazy","","Specialized version of parse_state where the parser does not need to add an error to the\n`ParseError` when it does not consume any input before encountering the error.\nInstead the error can be added later through the `add_error` method",10,{"inputs":[{"name":"parser"},{"name":"state"}],"output":{"name":"parseresult"}}],[11,"add_error","","Adds the first error that would normally be returned by this parser if it failed",10,{"inputs":[{"name":"parser"},{"name":"parseerror"}],"output":null}],[8,"ParserExt","","Extension trait which provides functions that are more conveniently used through method calls",null,null],[11,"with","","Discards the value of the `self` parser and returns the value of `p`\nFails if any of the parsers fails",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"with"}}],[11,"skip","","Discards the value of the `p` parser and returns the value of `self`\nFails if any of the parsers fails",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"skip"}}],[11,"and","","Parses with `self` followed by `p`\nSucceds if both parsers succed, otherwise fails\nReturns a tuple with both values on success",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"and"}}],[11,"or","","Returns a parser which first parses using `self`. If `self` fails without consuming any\ninput it then continues by trying to parse using `p`",14,{"inputs":[{"name":"parserext"},{"name":"p2"}],"output":{"name":"or"}}],[11,"then","","Parses using `self` and then passes the value to `f` which returns a parser used to parse\nthe rest of the input",14,{"inputs":[{"name":"parserext"},{"name":"f"}],"output":{"name":"then"}}],[11,"map","","Uses `f` to map over the parsed value",14,{"inputs":[{"name":"parserext"},{"name":"f"}],"output":{"name":"map"}}],[11,"message","","Parses with `self` and if it fails, adds the message `msg` to the error",14,{"inputs":[{"name":"parserext"},{"name":"s"}],"output":{"name":"message"}}],[11,"expected","","Parses with `self` and if it fails without consuming any input any expected errors are replaced by\n`msg`. `msg` is then used in error messages as \"Expected `msg`\".",14,{"inputs":[{"name":"parserext"},{"name":"s"}],"output":{"name":"expected"}}],[11,"and_then","","Parses with `self` and applies `f` on the result if `self` parses successfully\n`f` may optionally fail with an error which is automatically converted to a `ParseError`",14,{"inputs":[{"name":"parserext"},{"name":"f"}],"output":{"name":"andthen"}}],[11,"iter","","Creates an iterator from a parser and a state. Can be used as an alternative to `many` when\ncollecting directly into a `FromIterator` type is not desirable",14,{"inputs":[{"name":"parserext"},{"name":"state"}],"output":{"name":"iter"}}]],"paths":[[3,"ParseError"],[3,"State"],[3,"SourcePosition"],[3,"BytePosition"],[4,"Info"],[4,"Error"],[4,"Consumed"],[8,"Stream"],[8,"Range"],[8,"Positioner"],[8,"Parser"],[3,"SliceStream"],[3,"IteratorStream"],[3,"Box"],[8,"ParserExt"],[3,"Any"],[3,"Satisfy"],[3,"Token"],[3,"Choice"],[3,"Unexpected"],[3,"Value"],[3,"NotFollowedBy"],[3,"Iter"],[3,"Many"],[3,"Many1"],[3,"SkipMany"],[3,"SkipMany1"],[3,"SepBy"],[3,"SepBy1"],[3,"SepEndBy"],[3,"SepEndBy1"],[8,"FnMut"],[3,"FnParser"],[3,"Optional"],[3,"Between"],[3,"Chainl1"],[3,"Chainr1"],[3,"Try"],[3,"And"],[3,"With"],[3,"Skip"],[3,"Message"],[3,"Or"],[3,"Map"],[3,"Then"],[3,"Expected"],[3,"AndThen"],[3,"EnvParser"],[3,"Digit"],[3,"Space"],[3,"Spaces"],[3,"NewLine"],[3,"CrLf"],[3,"Tab"],[3,"Upper"],[3,"Lower"],[3,"AlphaNum"],[3,"Letter"],[3,"OctDigit"],[3,"HexDigit"],[3,"String"]]};
initSearch(searchIndex);
